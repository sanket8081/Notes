
#Why Spring?
Spring is a very popular framework for building enterprise Java applications.
When Spring first came out, it was initially a simpler, lightweight alternative to J2EE.
They basically give you a large number of helper classes to make enterprise development easier.


#Goals of Spring
1)Lightweight development with Java POJOs, and POJOs mean Plain Old Java Objects, make it much simpler to build, as compared to the heavyweight EJBs
from the early versions of J2EE.
2)We want to promote loose coupling by making use of dependency injection.
So instead of hard wiring your objects together,you simply specify the wiring via a configuration file or annotations
3)Declarative programming
with Aspect Oriented Programming, or AOP. This'll basically allow you to add some application wide services to your given objects.
4)Minimize boilerplate Java code.
So in the early days of J2EE, there was a lot of code that you had to write, and so the folks at Spring, they created a collection of helper classes
to make it easier, and again, to minimize all of the boilerplate code,





 

#Inversion of Control

It's simply the design process
of outsourcing, the construction and management of your objects.
In a nutshell it basically says  that your application's going to outsource the creation and management of the objects,
and that outsourcing will be handled by a object factory,

Make use of a software engineering best practice and that's to code to an interface.
So instead of coding directly to theBaseballCoach implementation, we want to make use of a well
defined interface that all coaches will support.

@Override
Indicates that a method declaration is intended to override a method declaration in a supertype. 
If a method is annotated with this annotation type compilers are required to generate an errormessage unless at least one of the following conditions hold: 
•The method does override or implement a method declared in asupertype. 
•The method has a signature that is override-equivalent to that ofany public method declared in Object. 


# What is a Spring Bean?
A "Spring Bean" is simply a Java object.
When Java objects are created by the Spring Container, then Spring refers to them as "Spring Beans".
Spring Beans are created from normal Java classes .... just like Java objects.

# beans xmlns (Inside applicationContext.xml)
Header information here for the xml name spaces, and that's what's required for Spring to be able to process this file using
its grammar and xml schema,


#Head's up: 
In Spring 5.1, the Spring Development team changed the logging levels internally. 
As a result, by default you will no longer see the red logging messages at the INFO level. 

#Why do we specify the Coach interface in getBean()?
For example:
Coach theCoach = context.getBean("myCoach", Coach.class); 
Answer:
When we pass the interface to the method, behind the scenes Spring will cast the object for you.
context.getBean("myCoach", Coach.class)  
However, there are some slight differences than normal casting.



#Dependency Injection

Dependency Injection is a fundamental aspect of the Spring framework, through which the Spring container “injects” objects into other objects or “dependencies”.
This allows for loose coupling of components and moves the responsibility of managing components onto the container.


Considering car factory as an example.

So, you don't have to actually build the car. The car's already built for you at the factory. So, they actually inject all of the dependencies for the car.
So they inject the engine, they inject the tires, the seats and so on. So that's basically what you have here with dependency injection.
So you simply outsource the construction and injection of your object to an external entity. In this case, that's the car factory.

Spring Container Primary functions:

1.Create and manage Objects. (Inversion of Control)
2.Inject Object's dependencies. (Dependency Injection)

Ex: As seen in previous implementation , Our coach provides daily workouts.
	Now, it will provide daily fortunes. This will be new helper named as FortuneService.
	This is dependency. and now we will inject this dependency in our Coach.

Two Main Injection Types:
1. Constructor Injection
2. Setter Injection

#Constructor Injection
# Process for Constructor Injection:
	1.Define the dependency interface and class.
	2.Creates a constructor in your class for injection.
	3.Configure the dependency injection in Spring config file.
	
Here, we use <constructor-arg ref="myFortune"/> for dependency injections.
	
FAQ: What is the purpose for the no arg constructor?
	 When you don’t define any constructor in your class, compiler defines default one for you, however when you declare any constructor 
	 (in your example you have already defined a parameterized constructor), compiler doesn’t do it for you.
	 Since you have defined a constructor in class code, compiler didn’t create default one. While creating object you are invoking default one, 
	 which doesn’t exist in class code. Then the code gives an compilation error.
	 

#Setter Injection
#Process for Setter Injection:
	1.Create setter methods in your class for injections.
	2.Configure the dependency injection in Spring Config file.
	
#Injecting Literal Values
#Process for Literal Injection
	1.Create setter methods in your class for injections.
	2.Configure the dependency injection in Spring Config file.
	
#Injecting values from a Propertirs file:
#Process for Injecting values from aproperties file:
	1.Create properties file.
	2.Load properties file in Spring config file.
	3.Reference values from Properties file.