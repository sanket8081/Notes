#Inversion of Control

It's simply the design process
of outsourcing, the construction and management of your objects.
In a nutshell it basically says  that your application's going to outsource the creation and management of the objects,
and that outsourcing will be handled by a object factory,

Make use of a software engineering best practice and that's to code to an interface.
So instead of coding directly to theBaseballCoach implementation, we want to make use of a well
defined interface that all coaches will support.

@Override
Indicates that a method declaration is intended to override a method declaration in a supertype. 
If a method is annotated with this annotation type compilers are required to generate an errormessage unless at least one of the following conditions hold: 
•The method does override or implement a method declared in asupertype. 
•The method has a signature that is override-equivalent to that ofany public method declared in Object. 


# What is a Spring Bean?
A "Spring Bean" is simply a Java object.
When Java objects are created by the Spring Container, then Spring refers to them as "Spring Beans".
Spring Beans are created from normal Java classes .... just like Java objects.

# beans xmlns (Inside applicationContext.xml)
Header information here for the xml name spaces, and that's what's required for Spring to be able to process this file using
its grammar and xml schema,


#Head's up: 
In Spring 5.1, the Spring Development team changed the logging levels internally. 
As a result, by default you will no longer see the red logging messages at the INFO level. 

#Why do we specify the Coach interface in getBean()?
For example:
Coach theCoach = context.getBean("myCoach", Coach.class); 
Answer:
When we pass the interface to the method, behind the scenes Spring will cast the object for you.
context.getBean("myCoach", Coach.class)  
However, there are some slight differences than normal casting.