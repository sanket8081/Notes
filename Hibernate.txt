#Hibernate - 01/03/2022Hibernate: Java based ORM tool which provides a framework for mapping app domain objects to the relational DB table nad vice versa.It maps Java objects and generated required SQL statements to replicate all operations to the DB.#JPA:JPA is just a specification that facilitates object-relational-mapping to manage relational data in Java app.JPA is jsut a Specification, but Hibernate is a JPA implementation.It provides a platform to work directly with objects instead of using SQL statements.Hibernate is one of the JPA implementation.(Jakatra Persistence API)Other implementation of JPA are:	EclipseLink	TopLink	MyBatis#What is Hibernate?Hibernate is a framework for persisting or saving java objects into a database.But basically at very high level, you'll have your Java application, it'll make use of this Hibernate framework and you can use it for saving and retrieving data from the database.
Hibernates uses JDBC to interact with DB#Benefits of Hibernate:1.Hibernate handles all of the low level SQL code.So it actually minimizes the amount of JDBC code you have to develop.
2.So Hibernate actually provides the Object-to-Relational Mapping(ORM).And it makes it really easy to create apps that store and retrieve objects from the database.So, as a developer you need to tell how Hibernate how your Java class or object how it maps to data in the database.//Saves the object:session.save(JavaObj);//retrives the objectsession.get(ClassName.class,primaryKey);//Querying for Java Objects:Query query = session.createQuery("from Student");List<Student> students =  query.list();#Relation between Hibernate and JDBC(Hibernate uses JDBC in the background for communicating with the database)1.Well, Hibernate actually uses JDBC for all database communications, so really,Hibernate is just another layer of extraction on top of JDBC.
2.So when your application uses the Hibernate framework, your app will store and retrieve objects using the Hibernate API.3.Hibernate does all of the low level JDBC work,and submitting the SQL queries and so on.
  So Hibernate does a lot of the low level work for you, but in the background it all goes through the standard JDBC API.Hibernate 5.2 requires Java 8. Hibernate Dev Process:1.Add Hibernate Configuration file2.Annotate Java Class3.Develop Java Code to perform DB Operations.#Wrting Hibernate Confgiuration File:Hibernate uses JDBC in a background for communicating with the DB.So Hibernate config file has the url,user_id,passwordhibernate.cfg.xml<hibernate-configuration>	<session-factory>		<!--  JDBC Database connection settings  -->		<property name="connection.driver_class">com.mysql.cj.jdbc.Driver</property>		<property name="connection.url">jdbc:mysql://localhost:3306/hb_student_tracker?useSSL=false&serverTimezone=UTC</property>		<property name="connection.username">hbstudent</property>		<property name="connection.password">hbstudent</property>		<!--  JDBC connection pool settings ... using built-in test pool  -->		<property name="connection.pool_size">1</property>		<!--  Select our SQL dialect  -->		<property name="dialect">org.hibernate.dialect.MySQLDialect</property>		<!--  Echo the SQL to stdout  -->		<property name="show_sql">true</property>		<!--  Set the current session context  -->		<property name="current_session_context_class">thread</property>	</session-factory></hibernate-configuration>#Hibernate AnnotationEntity Class: Java class that is mapped to database tableWe can implement mapping using below two options:1.XML config file(legacy)2.Java annotations(modern,preferred)	a.map class to DB table	b.map fields to DB columns	@Entity@Table(name="ABC")@Id  --> Primary Key@Column(name="")Naming conventions:Feild name should follow camel caseDB column name should follow underscore name ##HEADS UP - FOR JAVA 9 USERS  --Refer it from tutorial#Why we are using JPA Annotation instead of Hibernate ?For example, why we are not using this org.hibernate.annotations.Entity?ANSWER:JPA is a standard specification. Hibernate is an implementation of the JPA specification.Hibernate implements all of the JPA annotations.The Hibernate team recommends the use of JPA annotations as a best practice.#Can Hibernate generate database tables based on the Java code?Answer:<!– Drop and re-create the database schema on startup –><property name=”hbm2ddl.auto”>create</property> Automatically validates or exports schema DDL to the database when the SessionFactory is created.With create-drop, the database schema will be dropped when the SessionFactory is closed explicitly.hbm2ddl.auto–>create -Always create new schemahbm2ddl.auto–>update -Update existing schema#SessionFactory:Reads the hibernate config fileCreates Session OnjectsHeavy-weight objectOnly create once in your app#SessionWraps a JDBC connectionMain object used to save/retrive obejectsShort lived objectRetrived from SessionFactory#If config file name not given, Hibernate will lookfor default file name: hibernate.cfg.cmlExample:SessionFactory factory = new Configuration()						.configure("hibernate.cfg.xml")						.addAnnotatedClass(Student.class)						.buildSessionFactory();						Session sessions =  factory.getCurrentSession();try{}finally{	factory.close();}#Saving a java object:try{		//create a student object		Student tempStudent = new Student("Paul","Wall","paul@luv.com");				//start session		session.beginTransaction();				//save the student		session.save(tempStudent);				//commit the transaction		session.getTransaction().commit();		}finally{		factory.close();	}#Primary KeysUniquely identifies each row in a tableMust be a unique valueCannot contain NULL values@Id   //This given field is a primary key@GeneratedValue(strategy=GenerationType.IDENTITY)    //This column will be used for generation strategy@Column(name="id")private int id;#Different generation strategiesGenerationType.AUTO  ==> Pick an appropriate strategy for the particular DBGenerationType.IDENTITY  ==> Assigns primary keys using DB identiity column   //MYSQL Auto increementGenerationType.SEQUENCE  ==> Assign primary keys using a DB sequence   //Oracle sequenceGenerationType.TABLE  ==> Assign primary keys using an underlying DB table to ensure uniqueness#We can also define our own custom generation strategy	1.Create implementation of org.hibernate.id.IdentifierGenerator	2.Override the method: public Serializable generate(...)This always generate unique valueTake extra care, while working in high-volume,multi-threaded environment#Changing the starting index of AUTO_INCREMENTalter table <TABLE_NAME> AUTO_INCREMENT=3000;#How do I reset the AUTO_INCREMENT value to 1?truncate <TABLE_NAME>;   // This will delete all rows in the table sets the AUTO_INCREMENT to 1.#Retriving an Object//Creating a JAVA ObjectStudent theStudent =  Student(1,"Sanket","Deshmukh");//save it ot DBsession.save(theStudent);//Retriving an object from DB using the primary key.Student myStudent =  session.get(Student.class,theStudent.getId());#Querying Object with HibernateHQL - Hibernate Query LanguageQuery lang for retieving objectsSimilar in nature to SQL (where,like,order by,join,in,etc)EX: Retrieving all Srudents//Student is the Java class nameList<Student> theStudents =  session.createQuery("from Student")  							 .getResultList();//Student is the Java class name//s.name here is the Java Class property (not column name)List<Student> theStudents =  session.createQuery("from Student s where s.name like '%S%' ") 							 .getResultList();																			 #Note:If you are using Hibernate 5.2 or higher, then the Query list() method has been deprecated.In your code you should make the following update:Replacesession.createQuery("from Student").list()Withsession.createQuery("from Student").getResultList()#Priting Query param value sin logs/console:When using Hibernate, if you log the Hibernate SQL statements, you will see this:Hibernate: insert into student (email, first_name, last_name, id) values (?, ?, ?, ?)However, for debugging your application, you want to see the actual parameter values in the Hibernate logs.Basically, you want to get rid  of the question marks in the Hibernate logs.To view parameter values, we can add a logging framework to our project. For this example, we will make use of the Logback project. Logback does not use any log4j source code. Logback is a separate and independent project.#Updating Java Objectint studentId = 1;Student myStudent =  session.get(Student.class,studentId);//Update first name to "Scooby"myStudent.setFirstName("Scooby");//Commit the transactionsession.getTransaction().commit();No need to explicitly call session.save() or update(), as myStudent is a persistence object we retrive from the DB,will use the appropriate setter methods.#Update Query using create Query:session.createQuery("update Student set email='abc@gmail.com'");		.executeUpdate();#Deleting objects using hibernateint studentId = 1;Student myStudent =  session.get(Student.class,studentId);//Update first name to "Scooby"session.delete(myStudent);//Commit the transactionsession.getTransaction().commit();#Update Query using create Query:session.createQuery("delete Student where email='abc@gmail.com'");		.executeUpdate();		//executeUpdate is mostly used for updates and delete						#Storing DatesWe need to add a DateUtils class to handle parsing and formatting dates. The date formatter uses special symbols for formatting/parsing.-  dd:  day in month (number)-  MM:  month in year (number)- yyyy: yearSee this link for details: https://docs.oracle.com/javase/tutorial/i18n/format/simpleDateFormat.htmlimport java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date; public class DateUtils {        private static SimpleDateFormat formatter = new SimpleDateFormat("dd/MM/yyyy");        // read a date string and parse/convert to a date    public static Date parseDate(String dateStr) throws ParseException {        Date theDate = formatter.parse(dateStr);                return theDate;            }        // read a date and format/convert to a string    public static String formatDate(Date theDate) {                String result = null;                if (theDate != null) {            result = formatter.format(theDate);        }                return result;    }}#Add date field to Student classWe need to add a date field to the Student class. We map this field to the database column, "date_of_birth". Also, we make use of the @Temporal annotation. This is a Java annotation for storing dates.    @Column(name="date_of_birth")    @Temporal(TemporalType.DATE)        private Date dateOfBirth;#Hibernate Advanced Mapping	1)One to One	2)One to Many, Many to One	3)Many to Many	1) One to One	An instructor can have an "instructor detail" entity	Instructor --> Instructor Detail	2) One to Many	An instructor can have many courses				-->Course 0	Instructor  -->Course 1				-->Course 2									3) Mnay to Many	A course can have many students.	A student can have many courses.	#Important DB Concepts:	Primary Key: 		identify a unique row in a table	Foreign Key: 		Link tables together		A field in one table that refers to primary key in another table.		Main purpose is to preserve relationship between tables			Referential Integroty		Prevents operations that would destroy relationship		Ensures only valid data is inserted into foreign key column			Can only contain valid reference to primary key in other table.						Cascading: 		You can cascade operations.		Apply the same operation to related entities		If you have linked these two entities, and if you perform save operation on Instructor, then it will also perform		save operation on Instructor detail		Instructor  --> Instructor detail		Now, if we delete an instructor, we should also delete their instructor_detail. This is known as CASCADE DELETE		CASCADE DELETE	depends on the use case, it should not be used in case of many to many mapping.	Fetch Types: Eager Vs Lazy Loading		When we fetch data, should we retrieve everything?			Eager will retrieve everything.			Lazy will retrieve on request.	Uni-Directional: Instructor --> Instructor detail	Bi-Directional: Instructor <--> Instructor detail		#Entity Lifecycle and session methods:Refer Image in JAVA_INTERVIEW_PREP#CASCADE TYPESPERSIST - if entity is persisted/saved, related entity will also be persisted.REMOVE 	- if entity is removed/deleted, related entity will also be deletedREFRESH - if entity is refresh, related entity will also be refreshDETACH - if entity is detach(not associated with session), then related entity will also be detachedMERGE - if entity is merged, related entity will also be mergedALL - all of the above cascade types.Example:By default, no operations are cascaded.@OneToOne(cascade=CascadeType.ALL)@JoinColumn(name="instructor_detail_id")private InstructorDetail instructorDetail;#Configuring Mutiple Cascade Type@OneToOne(cascade={	CascadeType.DETACH,	CascadeType.MERGE,	CascadeType.REMOVE})@JoinColumn(name="instructor_detail_id")private InstructorDetail instructorDetail;#One to ManyEx: One instructor many coursesBi-directional				<-->Course 0	Instructor  <-->Course 1				<-->Course 2				#Many to OneMany courses can have one instructorInverse/Opposite of One-to-many#Basic and important requirementIf you delete an instructor,do delete the courses.If you delete a course,do delete the instructor.To avoid such mistakes, do not apply cascade delete or cascade all.#More on mappedBy:public class Instructor{	@OneToMany(mappedBy="instructor",	cascade={CascadeType.PERSIST,CascadeType.MERGE,CascadeType.DETACH,CascadeType.REFRESH}	)	private List<Course> courses;}public class Course{	@ManyToOne(cascade={CascadeType.PERSIST,CascadeType.MERGE,	CascadeType.DETACH,CascadeType.REFRESH})	@JoinColumn(name="instructor_id")	private Instructor instructor;}mappedBy tells hibernate:	Look at the instructor property in the Course class	Use information	from the Course class @JoinColumn	To help find associated courses for instructor			#Eager Vs lazy loading				-->Course 0	Instructor  -->Course 1				-->Course 21.Eager Loading:	Eager loading will load all dependent entities.	It will load instructor and all their courses at once.	This will have a major impact, if you have huge number of courses.	If we are searching instructor by a keyword, we only want list of matching instructors.	But, Eager loading would still load all the course for each instructor.	So, the best practice is only load data when absolutely needed. Prefer lazy loading instead of eager loading.2. Lazy Loading	It will load the main entity first and then load the dependent entities on demand(lazy)	Ex: In Lazy Loading it will load the instructor entity first and later it will load all dependent courses if requested.	When you lazy load,the data is retrived on demand.	However,this requires an open hibernate session,need an connection to DB to retrieve data.	If hibernate session is closed, and you attempt to retrieve lazy data, Hibernate will throw an exception.	Most common techniques to retrieve data using lazy loading:		Option 1: session.get and call appropriate getter methods.		Option 2: Hibernate query with HQL.	Real world Use case:	1.In master view, use lazy loading for search results.	Only load instructors, not thier courses.	2.In Detail view,retrieve the entity and necessary dependent entities	Load instructor and thier courses.	Sample Structure:	instructor_id	instructor_name	view_details#Fetch Type;When you define the mapping relationship.You can specify the fetch type: EAGER vs LAZYEX:public class Instructor{	@OneToMany(fetch=FetchType.LAZY,mappedBy="instructor",	cascade={CascadeType.PERSIST,CascadeType.MERGE,CascadeType.DETACH,CascadeType.REFRESH}	)	private List<Course> courses;}#Deafult FetchTypes:	@OnetoOne --> EAGER	@OnetoMany --> LAZY	@ManytoOne --> EAGER	@ManytoMany --> LAZY